# Задача 3.

Цель: познакомиться с основами 2D графики; познакомиться с применением Аффинных преобразований и использованием упрощённой модели с *Экранным* и *Реальным* прямоугольниками.

Задание: **разработать приложение согласно варианту.**

* * *

## Общие пожелания/требования.

**При разработке программы использовать подходы и архитектуру, рассмотренные на занятиях.**

*****<ins>!!! Огромная просьба ознакомиться с этими пожеланиями. В них Вы можете обнаружить некоторые советы, которые позволят Вам сделать более правильную архитектуру. Кроме того, тут представлены общие требования ко всем задачам. !!!</ins>*****

А) Во всех вариантах должна быть предусмотрена возможность управления областью просмотра. В идеале с помощью клавиатуры и дополнительно с помощью мыши. В простом случае будет достаточно соответствующего UI. Также, вероятно, стоит добавить вывод координатных осей, для ориентирования.

Б) Основные объекты задачи должны быть вынесены в классы (модели).

В) **!!! Все линии должны рисоваться с помощью алгоритмов, разработанных в рамках задачи №2 !!!** Данное требование стоит реализовывать через использование интерфейсов LineDrawer, ArcDrawer и др.

*Актуально для заданий, где требуется рисовать арки:*

Учитывая, что на момент выполнения данного задания собственная реализация алгоритма рисования арок и эллипсов может быть не готова, Вам потребуется воспользоваться возможностями Graphics'а (т.е. сделать "*class GraphicsArcDrawer implements ArcDrawer {}*"). После реализации собственного алгоритма ArcDrawer'а, останется, лишь, заменить фактически используемый экземпляр и продемонстрировать работоспособность.

Г) Нельзя использовать готовые инструменты, например, возможности graphics'а по повороту, масштабированию или перемещению системы координат.
Во всех задачах кроме №10 разрешается использовать уже готовый метод drawString или подобный для вывода текста. Это будет полезно для указания единиц масштаба (нумерация засечек на осях координат).

Д) Во всех задачах постараться предусмотреть возможность добавления на экран любого количества фигур и управления ими независимо друг от друга. Т.е. программа ***НЕ*** должна быть заточена под один экземпляр фигуры (в этом Вам должен был помочь пункт "Б"). Также было бы замечательно реализовать режим редактирования фигуры при помощи мыши (см. след. пункт "Е").

#### <ins>Следующие пункты не обязательны для реализации в полной мере претендентам на "удовл."</ins>

Е) В большинстве задач требуется хранить элементы программы (фигуры) в виде объектов, параметры которых должны быть доступны пользователю для редактирования.
В первом приближении может хватить соответствующего пользовательского интерфейса, но, конечно же, хотелось бы иметь возможность управлять некоторыми характеристиками с помощью мыши, как это сделана в известных программах (графические редакторы).
Например, в задачах №№ 1, 2, 5, 6 можно с помощью мыши менять позиции опорных точек. А в задачах №№ 7, 8, 9, 10, 11, 12 можно было бы менять положение фигуры, а также углы поворота и размеры/радиусы фигуры.
Для удобного решения этой задачи потребуется разработка режима редактирования, который будет, как бы, включаться, когда курсор находится над фигурой. Для этого Вам потребуется определить соответствующий метод определения, находится ли точка внутри фигуры (для начала, перевод в режим редактирования можно сделать, с помощью соответствующего UI). Также, вероятно, потребуется сделать метод, возвращающий координаты точек (опорных точек), с помощью которых можно проводить редактирование. Основная программа просто будет запрашивать их у фигуры и в этих местах рисовать маркеры (маленькие кружочки и/или квадратики, которые можно нарисовать с помощью готовых методов graphics'а), за которые потом можно будет тянуть. Далее, при обнаружении, что курсор находится в одном из этих маркеров и начинает двигаться, передавать соответствующие изменения в фигуру (старые и новые координаты курсора), чтобы она могла применить их к себе и сохранить результат. Возможно, потребуется сделать несколько видов маркеров, а для организации перемещения фигуры можно попробовать обойтись вообще без маркеров.
Также было бы приятно увидеть реализацию, где все эти основные методы вынесены в интерфейс, программа оперирует интерфейсом, а Ваша фигура его реализует. Ниже приведён <ins>возможный</ins> вариант такого интерфейса. Его, конечно же, **можно и нужно** корректировать при необходимости.
```
interface IFigure {
    void draw(ScreenConverter, PixelDrawer); /*Метод, который каждая фигура реализует самостоятельно и рисует себя с помощью PixelDrawer'а с применением ScreenConverter'а. Можно несколько развить эту мысль и разработать интерфейс IPrimitiveDrawer, который бы скрывал в себе всю логику преобразований и предоставлял бы программисту лишь конечный инструмент по рисованию линий.*/
    List<RealPoint> getMarkers(); /*Возвращает координаты маркеров. Может потребоваться создание нескольких подобных методов для возвращения разных типов маркера*/
    void moveMarker(RealPoint from, RealPoint to); /*Данный метод должен применять изменения по перемещению маркеров. В текущей реализации указываются исходная и конечная точки, а фигура должна сама понять, что произошло*/
    /*Вместо работы с RealPoint'ами, может, лучше работать с ScreenPoint'ами*/
}
```
Можно выделить логику маркера в отдельный интерфейс и сделать так, чтобы метод moveMarker был реализован уже у него и он сам бы принимал решение о том, как именно должна измениться фигура и менял бы её.

Ж) В задачах на построение графиков функций (№№ 3, 4, 13) необходимо применить архитектурное решение, позволяющее заменять рисуемую функцию на лету. Внешне для пользователя это должно выглядеть как, например, ComboBox, в котором пользователь выбирает рисуемую функцию. Внутри же потребуется разработать интерфейс:
```
public interface IFunction {
    double compute(double x); /*Кроме x может потребоваться передача и других параметров, от которых зависит построение функции. Надо подумать и принять обоснованное решение о том, какие ещё параметры передавать на данном этапе*/
}
```
Далее, для каждой конкретной функции Вам потребуется написать класс, реализующий интерфейс IFunction.
Основной же метод рисования, в идеале, должен принимать экземпляр IFunction, ScreenConverter, LineDrawer и м.б. ещё что-то необходимое для конкретной задачи.
Метод рисования графика не должен привязываться к конкретной реализации самой функции.
В задаче №3 надо предусмотреть корректное рисование разрывов. Возможно в IFunction потребуется добавить методы для определения точек разрыва.
В задаче №4 потребуется разработать
```
interface ITimeDependentParam {
    double getParamValue(double t);
}
```
После чего разработать классы для функций f(t), реализующие этот интерфейс.
У интерфейса IFunction в методе compute добавится ещё один аргумент - текущее время t.
А классы, реализующий интерфейс IFunction будут хранить у себя все свои параметры в виде ITimeDependentParam и в реализации compute будут просто запрашивать у параметров текущие значения.
В задаче №13 было бы замечательно предусмотреть возможность абстрагирования от того, сколько параметров требуется передать в функцию. Для этого можно попробовать при вычислении передавать кроме x словарь с соответствием каждой переменной её значения. Конечно же, потребуется в IFunction добавить метод, возвращающий массив с именами требуемых параметров. Это <ins>один из возможных</ins> подходов.

* * *

## Варианты:

1. (42) Написать программу для построения многоугольников со скруглениями радиуса R.
    Программа должна позволять создавать любое количество фигур и управлять ими при помощи мыши
    (в т.ч. при создании указывать точки, после создания - перемещать точки)
    
2. (38) Написать процедуру пересечения двух произвольных треугольников, заданных на плоскости.
    Программа должна позволять задавать параметры двух треугольников. Было бы замечательно, если бы треугольники можно было изменять с помощью мыши.
    Основной метод должен принимать два треугольника в качестве аргумента и возвращать упорядоченный набор точек для построения контура пересечения.
    
3. (40-49) Написать программу построения графика функции, заданной на плоскости.
    Предусмотреть корректное отображение разрывов.
    Варианты функций:
    * y = e^sin(x\*3)
    * y = x^3 - x^2
    * y = x^(1/3) \* sin(x)
    * y = ln(x^2 + 1) / (x^2 + 2)
    * y = (1 / (x^2 + 1))
    * y = abs(x^4 - x^3 + x^2 - x)
    * y = x^4 - abs(x^3)
    * (\*) y = e^((sin(x) + cos(x)) / (x^2 + 1)) 
    * (\*) Сделать интерпретатор для ввода собственных функций

4. (48) Написать программу динамического изменения графика функции на плоскости. (динамическое изменение задается ещё одной функцией от (t)).
    Варианты функций:
    * ) y = A\*x^2 + B\*x + C
    * ) y = A\*sin(W\*x + F) + C
    
    Каждый параметр зависит от какого-то t по одному из законов (независимо от остальных):
    * ) f(t) = a\*sin(w\*t+fi) + c
    * ) f(t) = a\* 1/(1+e^(-b\*t)) + c (сигмоида)
    
    После запуска программы пользователь выбирает желаемую функцию, задаёт для каждого параметра функции зависимость от времени (указывает параметры зависимости), 
    нажимает на кнопку запуска и по таймеру происходит изменение t и перерисовка изображения. 
    Скорость изменения t (шаг за секунду) и начальный момент времени также задаётся пользователем в специальном поле.
    
5. (25) Написать программу построения точки пересечения двух произвольных отрезков.
    Метод решающий задачу должен принимать две линии и возвращать точку, которую потом можно вывести на экран. 
    Предусмотреть ситуацию, когда две линии параллельны/совпадают.
    
6. (48) Написать процедуру постепенного превращения одной кривой, заданной набором точек, в другую кривую, заданную другим набором точек.
    Пользователь задаёт две кривые с помощью мыши через опорные точки и время, за которое одна кривая должна превратиться в другую. 
    После нажатия кнопки запуска происходит соответствующая анимация (программа должна каждый кадр вычислять "текущую" линию на основе двух граничных и текущего времени).
    Алгоритм рисования кривой реализовать самостоятельно. Например, кривую Безье или др. сплайны.
    
7. (35) Написать процедуру построения правильного многоугольника с заданным числом сторон. 
    Предусмотреть возможность управления размером и положением фигуры с помощью мыши 
    (будет удобно разработать режим редактирования, когда около углов появляются маркеры, за которые можно тянуть мышью).
    Пользователь должен иметь возможность задавать любое количество объектов и управлять ими по отдельности. 
    Каждый многоугольник задаётся координатами центра, радиусом описанной окружности(или длиной стороны), количеством сторон и т.н. начальным углом.
    
8. (43) Написать процедуру построения сегмента круга заданного радиуса. 
    Предусмотреть возможность управления размером и положением фигуры с помощью мыши 
    (будет удобно разработать режим редактирования, когда около углов появляются маркеры, за которые можно тянуть мышью).
    Пользователь должен иметь возможность задавать любое количество объектов и управлять ими по отдельности. 
    Каждый сегмент задаётся координатами центра, радиусом окружности, углами начала и окончания сегмента.
    
9. (45-50) Создать приложение, демонстрирующее выполнение аффинных преобразований на плоскости, на примере фигуры -- ромб и (\*) на примере эллипса (В качестве усложнённого варианта).
    Предполагается разработка гибкой архитектуры, где каждое преобразование будет наследоваться от какого-то базового интерфейса с объявленной функцией 
    трансформации точки. Далее потребуется сделать инструмент, который бы прозрачно для основной программы, 
    рисующей фигуру, применял эти преобразования к точкам перед их фактическим выводом на экран. Для этого потребуется создать интерфейс IAffine, в котором будет объявлен метод преобразования точки.
    После этого потребуется реализовать несколько классов для каждого преобразования. Далее можно сделать класс, 
    который будет также наследоваться от IAffine и хранить в себе другие преобразования (паттерн компоновщик).
    Ромб стоит унаследовать от какой-то IFigure.
    Далее где-то написать класс/метод, который бы умел рисовать список фигур с применением указанного Аффинного преобразования. 
    Таким образом, можно получить приложение, которому всё равно, какие фигуры рисуются и с применением каких преобразований (в т.ч. не будет важен порядок).
    В пользовательском интерфейсе должна быть возможность по настройке порядка и параметров применяемых преобразований.

10. (50) Написать процедуру, выводящую строку векторных символов с коэффициентом увеличения под любым углом.
    Требуется разработать класс StringDrawer, который будет уметь рисовать строки в разных направлениях, под разными углами букв и т.д. 
    Все параметры должны задаваться через setter'ы. Также разработать инструмент, загружающий необходимый шрифт из файла. 
    Сделать полностью собственную реализацию разбора файла.

11. (40) Написать процедуру построения  солнышка. Предусмотреть возможность управления размером и положением фигуры с помощью мыши 
    (будет удобно разработать режим редактирования, когда около углов появляются маркеры, за которые можно тянуть мышью).
    Пользователь должен иметь возможность задавать любое количество объектов и управлять ими по отдельности. 
    Каждое солнышко задаётся координатами центра, радиусами окружности и лучиков, количеством лучиков и начальным углом.

12. (30) Написать процедуру построения  звезды. Предусмотреть возможность управления размером и положением фигуры с помощью мыши 
    (будет удобно разработать режим редактирования, когда около углов появляются маркеры, за которые можно тянуть мышью).
    Пользователь должен иметь возможность задавать любое количество объектов и управлять ими по отдельности. 
    Каждая звезда задаётся координатами центра, радиусами окружности и лучиков, количеством лучиков и начальным углом.

13. (40-49) Написать программу построения графика функции, заданной на плоскости. Все параметры должны быть доступны для ввода вручную.
    Варианты функций:
    * y = A\*x^3 + B\*x^2 + C\*x + D
    * y = A\*sin(W\*x + F) + C
    * y = A1\*sin(W1\*x + F1)\*(A2\*cos(W2\*x + F2)+C2) + C1
    * y = A\*sin(W\*x + F)\*(e^(-x/T))+C
    * y = A\* 1/(1+e^(-x)) + C
    * y = A / (B\*x+D) + C
    * (\*) x = A\*y^3 + B\*y^2 + C\*y + D
    * (\*) Разработать свой собственный интерпретатор математических выражений.

14. (25) Нарисовать обычную [стрелку](https://www.pigmalion-journal.com/wp-content/uploads/%D0%9F%D1%80%D1%8F%D0%BC%D0%B0%D1%8F-%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BA%D0%B0.jpg).
    Предусмотреть возможность управления параметрами стрелки (исходная и конечная точки, длина и ширина самой стрелки) с помощью мыши.

15. (30) Нарисовать [координатную](https://lh3.googleusercontent.com/proxy/bmFoYW5vhZs6Fwxgsr1lMQRk-NajCBeM3XggbbqVlzbPGLMmFBuEq06jqvmftk9Wh9CtXgmnPvb7BjHzhq04tOqWTjAqat7eXEMVO3MeNC9nMf6EnRuSQDdoAnme1TSJB_UkTqLs5PPBqNCPjZHELUYTUvyzZjCT-zmnLTa5sWurqdrGNbVCK5fwR_XPzIkvqz5v0EJlwoJcOC5NEcVPYxs-gDul8T9Ue75cacF_hTnDZM6w6f4EOAeOdV3Vd-SG3dxxwCGaKOngpmvzymbuRuURtxLfNtIvwiLi41V7Bif3kqEpBACkYjK_ivEdTBcMXDYKLtEIij6Lgg) [сетку](https://corel.demiart.ru/book12/Glava_09/2.gif).
    Разработать приложение, выводящее на экран разлиновку. Шаг для каждой из осей должен подбираться автоматически. Вывод осей и значений крайне желателен. Предусмотреть возможность полноценного перемещения по двумерной плоскости и изменения масштаба. Добавить вывод координаты текущего положения мыши. (\*) Можно добавить возможность создания [логарифмических](https://upload.wikimedia.org/wikipedia/commons/4/40/Log_paper_with_labels.svg) шкал (желательно разработать зависимость через интерфейс).

16. (25) Многоугольник. Вычисление внешнего прямоугольника.
    Разработать приложение, позволяющее создавать и редактировать многоугольники (с помощью мыши). Предусмотреть возможность вычисления и вывода описывающего (внешнего) прямоугольника.
    Добавить возможность изменения размеров и положения всего многоугольника с помощью изменений характеристик прямоугольника (например, тянем за нижнюю границу прямоугольника и весь многоугольник растягивается по вертикальной оси, при этом верхняя граница остаётся на месте).

17. (25-30) Построение базовых фигур из [draw.io](https://draw.io) или [Word'а](http://www.lamer-stop.ru/wp-content/uploads/2015/06/figuri.png).
    Конкретная фигура утверждается преподавателем.

18. (30) Прямоугольная спираль.
    Предусмотреть возможность изменения параметров спирали с помощью мыши.

19. (35-40) Свечные диаграммы.
    Разработать приложение для вывода набора данных с помощью [диаграммы](http://fxcodebase.com/wiki/index.php/%D0%A2%D0%B8%D0%BF%D1%8B_%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC:_%D0%A1%D0%B2%D0%B5%D1%87%D0%BD%D0%B0%D1%8F_%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0).
    (\*) Учесть изменение внешнего вида при изменении масштаба. Т.е. адаптировать график под текущий масштаб и область просмотра.

20. (25-35) Пересечение или объединение прямоугольников.
    Разработать приложения для вычисления фигуры, являющейся результатом пересечения/(\*)объединения нескольких прямоугольников, стороны которых параллельны осям координат.
    Должна быть возможность редактировать прямоугольники с помощью мыши.
    Метод, решающий задачу должен принимать в качестве аргумента список экземпляров класса Прямоугольник и возвращать список из замкнутых линий (каждая линия -- набор точек).
    В случае пересечения, конечно же, результатом будет один прямоугольник. В случае объединения -- могут получиться несколько замкнутых линий.

21. (25) Нарисовать [зигзаг](https://lh3.googleusercontent.com/proxy/3Zmb9FvfKRgN6hnMFmCUdwn1aeVoXIX5s5IRKb7vW5Oe04GUaDbz1nLTu3Bdo5FxGMyx5MuFSfgVrvfavgPYMeafe_ZX1zpnAfkR7EOZK9w)/пилу вдоль прямой и, м.б., [другие](https://upload.wikimedia.org/wikipedia/commons/thumb/9/92/Waveforms_ru.svg/1200px-Waveforms_ru.svg.png). 
    Пользователь должен иметь возможность задать точки начала и конца зигзага с помощью мыши. Также должна быть возможность менять шаг, ширину и другие параметры.


